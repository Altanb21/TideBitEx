<!DOCTYPE html>
<html>
  <head>
    <title>TradingView Charting Library demo</title>

    <!-- Fix for iOS Safari zooming bug -->
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />

    <script
      type="text/javascript"
      src="charting_library/charting_library.min.js"
    ></script>
    <script
      type="text/javascript"
      src="datafeeds/udf/dist/polyfills.js"
    ></script>
    <script type="text/javascript" src="datafeeds/udf/dist/bundle.js"></script>

    <script>
      const transformTradesToCandle = (trades, resolution) => {
        let interval,
          data,
          defaultObj = {};
        switch (resolution) {
          case "1m":
            interval = 1 * 60 * 1000;
            break;
          case "30m":
            interval = 30 * 60 * 1000;
            break;
          case "1H":
            interval = 60 * 60 * 1000;
            break;
          case "1W":
            interval = 7 * 24 * 60 * 60 * 1000;
            break;
          case "M":
            interval = 30 * 24 * 60 * 60 * 1000;
            break;
          case "1":
          default:
            interval = 24 * 60 * 60 * 1000;
        }
        data = trades.reduce((prev, curr) => {
          const index = Math.floor((curr.at * 1000) / interval);
          let point = prev[index];
          if (point) {
            point.high = Math.max(point.high, +curr.price); // high
            point.low = Math.min(point.low, +curr.price); // low
            point.close = +curr.price; // close
            point.volume += +curr.volume; // volume
          } else {
            point = {
              time: index * interval,
              open: +curr.price,
              high: +curr.price,
              low: +curr.price,
              close: +curr.price,
              volume: +curr.volume,
            };
          }
          prev[index] = point;
          return prev;
        }, defaultObj);

        const now = Math.floor(new Date().getTime() / interval);
        for (let i = 0; i < 2000; i++) {
          if (!defaultObj[now - i])
            defaultObj[now - i] = {
              time: (now - i) * interval,
              open: 0,
              high: 0,
              low: 0,
              close: 0,
            };
        }

        return Object.values(data);
      };
      const supportedResolutions = [
        "1",
        "3",
        "5",
        "15",
        "30",
        "60",
        "120",
        "240",
        "D",
      ];

      const config = {
        supported_resolutions: supportedResolutions,
      };
      const Datafeed = {
        onReady: (cb) => {
          console.log("=====onReady running");
          setTimeout(() => cb(config), 0);
        },
        searchSymbols: (
          userInput,
          exchange,
          symbolType,
          onResultReadyCallback
        ) => {
          console.log("====Search Symbols running");
        },
        resolveSymbol: (
          symbolName,
          onSymbolResolvedCallback,
          onResolveErrorCallback
        ) => {
          // expects a symbolInfo object in response
          console.log("======resolveSymbol running");
          // console.log('resolveSymbol:',{symbolName})
          var split_data = symbolName.split(/[:/]/);
          // console.log({split_data})
          var symbol_stub = {
            name: symbolName,
            description: "",
            type: "crypto",
            session: "24x7",
            timezone: "Etc/UTC",
            ticker: symbolName,
            exchange: split_data[0],
            minmov: 1,
            pricescale: 100000000,
            // has_intraday: true,
            // intraday_multipliers: ["1", "60"],
            supported_resolution: supportedResolutions,
            volume_precision: 8,
            data_status: "streaming",
          };

          if (split_data[2].match(/USD|EUR|JPY|AUD|GBP|KRW|CNY/)) {
            symbol_stub.pricescale = 100;
          }
          setTimeout(function () {
            onSymbolResolvedCallback(symbol_stub);
            console.log("Resolving that symbol....", symbol_stub);
          }, 0);

          // onResolveErrorCallback('Not feeling it today')
        },
        getBars: function (
          symbolInfo,
          resolution,
          from,
          to,
          onHistoryCallback,
          onErrorCallback,
          firstDataRequest
        ) {
          console.log("=====getBars running");
          // console.log('function args',arguments)
          // console.log(`Requesting bars between ${new Date(from * 1000).toISOString()} and ${new Date(to * 1000).toISOString()}`)
          fetch(
            `https://legacy2.tidebit.network/api/v2/trades?market=${window.location.pathname.replace(
              "/markets/"
            )}`
          )
            // fetch(`https://legacy2.tidebit.network/api/v2/trades?market=${'ethhkd'}`)
            .then((response) => response.json())
            .then((data) => {
              // console.log(resolution);
              // console.log(data);
              const bars = transformTradesToCandle(data, resolution);
              // console.log(bars);
              console.log(bars);
              if (bars.length) {
                onHistoryCallback(bars, { noData: false });
              } else {
                onHistoryCallback(bars, { noData: true });
              }
            })
            .catch((err) => {
              console.log({ err });
              onErrorCallback(err);
            });
        },
        subscribeBars: (
          symbolInfo,
          resolution,
          onRealtimeCallback,
          subscribeUID,
          onResetCacheNeededCallback
        ) => {
          console.log("=====subscribeBars runnning");
        },
        unsubscribeBars: (subscriberUID) => {
          console.log("=====unsubscribeBars running");
        },
        calculateHistoryDepth: (resolution, resolutionBack, intervalBack) => {
          //optional
          console.log("=====calculateHistoryDepth running");
          // while optional, this makes sure we request 24 hours of minute data at a time
          // CryptoCompare's minute data endpoint will throw an error if we request data beyond 7 days in the past, and return no data
          return resolution < 60
            ? { resolutionBack: "D", intervalBack: "1" }
            : undefined;
        },
        getMarks: (
          symbolInfo,
          startDate,
          endDate,
          onDataCallback,
          resolution
        ) => {
          //optional
          console.log("=====getMarks running");
        },
        getTimeScaleMarks: (
          symbolInfo,
          startDate,
          endDate,
          onDataCallback,
          resolution
        ) => {
          //optional
          console.log("=====getTimeScaleMarks running");
        },
        getServerTime: (cb) => {
          console.log("=====getServerTime running");
        },
      };
    </script>

    <script type="text/javascript">
      function getParameterByName(name) {
        name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
          results = regex.exec(location.search);
        return results === null
          ? ""
          : decodeURIComponent(results[1].replace(/\+/g, " "));
      }

      function initOnReady() {
        var widget = (window.tvWidget = new TradingView.widget({
          // debug: true, // uncomment this line to see Library errors and warnings in the console
          fullscreen: true,
          symbol: window.location.pathname.replace("/markets/"),
          interval: "1",
          container_id: "tv_chart_container",

          //	BEWARE: no trailing slash is expected in feed URL
          datafeed: Datafeed,
          // datafeed: new Datafeeds.UDFCompatibleDatafeed("https://demo_feed.tradingview.com"),
          library_path: "charting_library/",
          locale: getParameterByName("lang") || "en",

          disabled_features: ["use_localstorage_for_settings"],
          enabled_features: ["study_templates"],
          charts_storage_url: "http://saveload.tradingview.com",
          charts_storage_api_version: "1.1",
          client_id: "tradingview.com",
          user_id: "public_user_id",
          theme: getParameterByName("theme"),
        }));
      }

      window.addEventListener("DOMContentLoaded", initOnReady, false);
    </script>
  </head>

  <body style="margin: 0px">
    <div id="tv_chart_container"></div>
  </body>
</html>
