import { parseFullSymbol } from "./helpers.js";

let ws,
  wsReConnectTimeout,
  timeout,
  connection_resolvers = [],
  url = "staging3.tidebit.network";

const send = (data) => {
  connection_resolvers.push(data);
  sendDataFromQueue();
};

const sendDataFromQueue = () => {
  if (ws) {
    if (ws.readyState === 1) {
      const data = connection_resolvers.shift();
      if (data) {
        ws.send(data);
        sendDataFromQueue();
      }
    } else {
      clearTimeout(timeout);
      timeout = setTimeout(() => sendDataFromQueue(), 1500);
    }
  }
};

function getNextDailyBarTime(barTime) {
  const date = new Date(barTime * 1000);
  date.setDate(date.getDate() + 1);
  return date.getTime() / 1000;
}

const listener = (msg) => {
  let metaData = JSON.parse(msg.data);
  console.log("[socket] Message:", metaData);
  switch (metaData.type) {
    case 'Candles':
      const [
        eventTypeStr,
        exchange,
        fromSymbol,
        toSymbol,
        ,
        ,
        tradeTimeStr,
        ,
        tradePriceStr,
      ] = metaData.split("~");

      if (parseInt(eventTypeStr) !== 0) {
        // skip all non-TRADE events
        return;
      }
      const tradePrice = parseFloat(tradePriceStr);
      const tradeTime = parseInt(tradeTimeStr);
      const channelString = `0~${exchange}~${fromSymbol}~${toSymbol}`;
      const subscriptionItem = channelToSubscription.get(channelString);
      if (subscriptionItem === undefined) {
        return;
      }
      const lastDailyBar = subscriptionItem.lastDailyBar;
      const nextDailyBarTime = getNextDailyBarTime(lastDailyBar.time);

      let bar;
      if (tradeTime >= nextDailyBarTime) {
        bar = {
          time: nextDailyBarTime,
          open: tradePrice,
          high: tradePrice,
          low: tradePrice,
          close: tradePrice,
        };
        console.log("[socket] Generate new bar", bar);
      } else {
        bar = {
          ...lastDailyBar,
          high: Math.max(lastDailyBar.high, tradePrice),
          low: Math.min(lastDailyBar.low, tradePrice),
          close: tradePrice,
        };
        console.log("[socket] Update the latest bar by price", tradePrice);
      }
      subscriptionItem.lastDailyBar = bar;

      // send data to every subscriber of that symbol
      subscriptionItem.handlers.forEach((handler) => handler.callback(bar));
      break;
    default:
  }
};

export const init = ({ url, market }) => {
  ws = new WebSocket("url");
  ws.onclose = (msg) => this.clear(msg);
  ws.onerror = async (err) => {
    console.error(`[TideBitWS] ws.onerror`, err);
    clearTimeout(wsReConnectTimeout);
    wsReConnectTimeout = setTimeout(async () => {
      await init({ url: url });
    }, 1000);
  };
  ws.onmessage = listener;
  return new Promise((resolve) => {
    if (ws)
      ws.onopen = (r) => {
        console.log("Socket is open");
        ws.send(
          JSON.stringify({
            op: "userStatusUpdate",
            args: {
              market,
            },
          })
        );
        return resolve(r);
      };
  });
};
const channelToSubscription = new Map();

export function subscribeOnStream(
  symbolInfo,
  resolution,
  onRealtimeCallback,
  subscribeUID,
  onResetCacheNeededCallback,
  lastDailyBar
) {
  const parsedSymbol = parseFullSymbol(symbolInfo.full_name);
  const channelString = `0~${parsedSymbol.exchange}~${parsedSymbol.fromSymbol}~${parsedSymbol.toSymbol}`;
  const handler = {
    id: subscribeUID,
    callback: onRealtimeCallback,
  };
  let subscriptionItem = channelToSubscription.get(channelString);
  if (subscriptionItem) {
    // already subscribed to the channel, use the existing subscription
    subscriptionItem.handlers.push(handler);
    return;
  }
  subscriptionItem = {
    subscribeUID,
    resolution,
    lastDailyBar,
    handlers: [handler],
  };
  channelToSubscription.set(channelString, subscriptionItem);
  console.log(
    "[subscribeBars]: Subscribe to streaming. Channel:",
    channelString
  );
  ws.emit("SubAdd", { subs: [channelString] });
}

export function unsubscribeFromStream(subscriberUID) {
  // find a subscription with id === subscriberUID
  for (const channelString of channelToSubscription.keys()) {
    const subscriptionItem = channelToSubscription.get(channelString);
    const handlerIndex = subscriptionItem.handlers.findIndex(
      (handler) => handler.id === subscriberUID
    );

    if (handlerIndex !== -1) {
      // remove from handlers
      subscriptionItem.handlers.splice(handlerIndex, 1);

      if (subscriptionItem.handlers.length === 0) {
        // unsubscribe from the channel, if it was the last handler
        console.log(
          "[unsubscribeBars]: Unsubscribe from streaming. Channel:",
          channelString
        );
        ws.emit("SubRemove", { subs: [channelString] });
        channelToSubscription.delete(channelString);
        break;
      }
    }
  }
}
